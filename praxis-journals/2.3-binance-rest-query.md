# 2.3 Binance REST: cancel order, query order, query open orders, query balance

## Sources

- RFC §REST operations: "Cancel order | DELETE /api/v3/order | Execution Manager"
- RFC §REST operations: "Query order | GET /api/v3/order | Execution Manager (reconnect)"
- RFC §REST operations: "Query open orders | GET /api/v3/openOrders | Execution Manager (reconnect)"
- RFC §REST operations: "Query balance | GET /api/v3/account | Recon Engine"
- RFC §Response normalization: "Venue Adapter translates Binance-specific responses into internal types."
- §2.1 journal: Protocol decided, response dataclasses and error hierarchy defined
- §2.2 journal: submit_order implemented, signing, session lifecycle, error mapping established

## Current state

praxis/infrastructure/venue_adapter.py has the VenueAdapter Protocol with 8 methods, 7 frozen response dataclasses (ImmediateFill, SubmitResult, CancelResult, VenueOrder, VenueTrade, BalanceEntry, SymbolFilters), and 6 error types (VenueError + 5 subclasses). 24 tests passing. Merged via PR #32.

praxis/infrastructure/binance_adapter.py has BinanceAdapter with submit_order, HMAC-SHA256 signing (_sign_params returns pre-encoded query string), session lifecycle, credential management, and error mapping. 48 unit tests + 3 testnet integration tests. Merged via PR #33.

Existing infrastructure from §2.2:
- _sign_params(params, api_secret) → str: returns pre-encoded signed query string, embedded directly in request URL to avoid yarl re-encoding
- _auth_headers(account_id) → dict: X-MBX-APIKEY header
- _raise_on_error(response) → None: maps HTTP status to VenueError subclass, with VenueError re-raise guard before broad transport catch
- _ensure_session() → ClientSession: lazy session creation
- _get_credentials(account_id) → tuple: credential lookup, raises AuthenticationError
- _map_order_status(binance_status) → OrderStatus: Binance status string to domain enum
- _build_order_params: submit-specific parameter builder, not reusable for §2.3

Response dataclasses already defined for §2.3 return types:
- CancelResult(venue_order_id: str, status: OrderStatus) — frozen
- VenueOrder(venue_order_id, client_order_id, status, symbol, side, order_type, qty, filled_qty, price) — frozen
- BalanceEntry(asset: str, free: Decimal, locked: Decimal) — frozen

tests/testnet/test_rest_auth.py has a manual balance query against GET /api/v3/account using raw aiohttp — provides reference for testnet assertions.

## Design decisions

### Shared request helper

§2.2 submit_order inlines the HTTP call: build params → sign → post → check error → parse JSON. §2.3 adds 4 more methods that all follow the same pattern with different HTTP methods and endpoints.

Options:
1. Inline each HTTP call per method (copy the submit_order pattern 4 more times)
2. Extract a private _signed_request helper that handles the common flow

Decision: Extract `_signed_request(method: str, path: str, params: dict[str, str], account_id: str) -> dict[str, Any]`. All 5 authenticated methods (including refactored submit_order) call this. The helper handles: get credentials → sign params → build URL with pre-encoded query string → make HTTP request via session.request(method, url) → check errors → parse JSON → return dict. The VenueError re-raise guard lives in the helper once, not duplicated in each method.

### Query string encoding for GET and DELETE

§2.2 fixed a signature mismatch by embedding the pre-encoded query string directly in the URL, bypassing aiohttp/yarl re-encoding. The same approach applies to GET and DELETE requests.

Decision: _signed_request builds the full URL as `{base_url}{path}?{query_string}` for all HTTP methods. No params= or data= arguments to aiohttp. Consistent across GET, POST, DELETE.

### cancel_order / query_order identifier resolution

Both methods accept venue_order_id and/or client_order_id (keyword-only, both optional). The Protocol docstring says "at least one must be provided." Binance uses orderId and origClientOrderId as the corresponding parameters.

Decision: Map venue_order_id → orderId, client_order_id → origClientOrderId. Raise ValueError if neither is provided. If both are provided, send both — Binance accepts this and orderId takes precedence. This is defensive: the caller may provide redundant identifiers.

### Binance side and type reverse mapping

submit_order maps domain enums to Binance strings (OrderSide.BUY → "BUY"). §2.3 needs the reverse for query_order and query_open_orders responses.

OrderSide enum values are uppercase strings matching Binance exactly ("BUY", "SELL"). OrderType values are also uppercase ("MARKET", "LIMIT", "LIMIT_IOC"). However, Binance returns type="LIMIT" for both our LIMIT and LIMIT_IOC orders — the distinction is in the timeInForce field.

Decision: Map side via direct enum construction: OrderSide(binance_side). For order type, use the Binance type + timeInForce combination: type=LIMIT + timeInForce=IOC → OrderType.LIMIT_IOC, type=LIMIT + any other TIF → OrderType.LIMIT, type=MARKET → OrderType.MARKET. Unknown types → ValueError (defensive).

### VenueOrder price for market orders

Binance returns price="0.00000000" for market orders. The VenueOrder dataclass has price: Decimal | None, with None for market orders per §2.1 convention.

Decision: Map Binance price to None when the resolved order_type is MARKET. For all other types, parse as Decimal.

### query_balance asset filtering

GET /api/v3/account returns the full account object including a balances array with every known asset (hundreds on testnet). The consumer only needs balances for assets it actively trades.

The current Protocol signature is `query_balance(account_id) -> list[BalanceEntry]` with no filter parameter. Returning everything forces the consumer to filter — but the consumer should not need to know about irrelevant assets.

Decision: Amend the Protocol to add a required `assets: frozenset[str]` parameter: `query_balance(account_id, assets) -> list[BalanceEntry]`. The adapter fetches /api/v3/account once, filters the balances array to only the requested asset symbols, and returns BalanceEntry for those. Required, not optional — there is no use case for returning all balances. This is a minor Protocol amendment in venue_adapter.py as part of §2.3.

### NotFoundError for missing orders

The current _raise_on_error maps all HTTP 400 responses to OrderRejectedError. For cancel_order and query_order, Binance returns HTTP 400 with specific error codes when an order does not exist:
- -2013: "Order does not exist."
- -2011: "Unknown order sent." (cancel-specific)

Decision: Define `_NOT_FOUND_CODES = frozenset({-2013, -2011})` constant. Refine _raise_on_error to check the parsed venue_code after reading the 400 body. If venue_code is in _NOT_FOUND_CODES → NotFoundError. All other 400 → OrderRejectedError (unchanged). This gives consumers a specific error type for "order not found" scenarios.

## Subitems

- [ ] 2.3.1 Extract _signed_request helper in binance_adapter.py
  - _signed_request(method, path, params, account_id) → dict[str, Any]
  - Handles: credential lookup, signing, URL construction, HTTP request, error check, JSON parse
  - VenueError re-raise guard and TransientError catch live in this helper
  - Refactor submit_order to use _signed_request
  - All existing submit_order tests must continue passing
- [ ] 2.3.2 Refine _raise_on_error for NotFoundError
  - Define _NOT_FOUND_CODES = frozenset({-2013, -2011})
  - Check venue_code after parsing 400 body → NotFoundError or OrderRejectedError
  - Existing error mapping tests must continue passing
- [ ] 2.3.3 Add _parse_venue_order helper
  - Private _parse_venue_order(data) → VenueOrder
  - Side mapping: OrderSide(data['side'])
  - Type mapping: _map_order_type(data['type'], data['timeInForce'])
  - Market price → None, all others → Decimal
  - Reused by query_order and query_open_orders
- [ ] 2.3.4 cancel_order implementation
  - DELETE /api/v3/order via _signed_request
  - Params: symbol, orderId and/or origClientOrderId
  - ValueError if neither identifier provided
  - Parse response → CancelResult(venue_order_id=str(orderId), status=_map_order_status(status))
- [ ] 2.3.5 query_order implementation
  - GET /api/v3/order via _signed_request
  - Params: symbol, orderId and/or origClientOrderId
  - ValueError if neither identifier provided
  - Parse response → VenueOrder via _parse_venue_order
- [ ] 2.3.6 query_open_orders implementation
  - GET /api/v3/openOrders via _signed_request
  - Params: symbol
  - Parse array response → list[VenueOrder] via _parse_venue_order
- [ ] 2.3.7 Amend query_balance Protocol signature in venue_adapter.py
  - Add assets: frozenset[str] parameter (required, positional)
  - Signature: query_balance(account_id: str, assets: frozenset[str]) -> list[BalanceEntry]
  - Update Protocol docstring
  - Update existing tests if any reference the old signature
- [ ] 2.3.8 query_balance implementation
  - GET /api/v3/account via _signed_request
  - Extract balances array, filter to entries where asset is in the requested assets set
  - Parse matching entries → list[BalanceEntry(asset, free, locked)]
- [ ] 2.3.9 Unit tests in tests/test_binance_adapter.py
  - _signed_request: verify URL construction, HTTP method dispatch, error handling
  - cancel_order happy path → CancelResult with CANCELED status
  - cancel_order with venue_order_id → orderId in params
  - cancel_order with client_order_id → origClientOrderId in params
  - cancel_order with neither identifier → ValueError
  - cancel_order 400/-2013 → NotFoundError
  - query_order happy path → VenueOrder with all fields mapped correctly
  - query_order LIMIT+IOC → OrderType.LIMIT_IOC
  - query_order MARKET price → None
  - query_order with neither identifier → ValueError
  - query_order 400/-2013 → NotFoundError
  - query_open_orders happy path → list[VenueOrder]
  - query_open_orders empty response → empty list
  - query_balance with specific assets → only requested BalanceEntry returned
  - query_balance asset not in response → omitted from result
  - query_balance all requested assets zero → empty list
- [ ] 2.3.10 Testnet integration tests in tests/testnet/test_binance_adapter.py
  - cancel_order: submit resting limit → cancel → verify CancelResult status CANCELED
  - query_order: submit resting limit → query → verify VenueOrder fields → cancel cleanup
  - query_open_orders: submit resting limit → verify in list → cancel cleanup
  - query_balance: query with {'BTC', 'USDT'} → verify both returned with non-zero
  - All use try/finally for resting order cleanup
  - Skip markers for unreachable testnet / missing credentials
- [ ] 2.3.11 Ruff + Mypy clean on all new and changed files

## Out of scope

- query_trades — deferred, not assigned to §2.3 by §2.2 out-of-scope
- get_exchange_info, get_server_time — §2.6
- Transient HTTP retries with backoff — §2.4
- Comprehensive response normalization — §2.5
- Rate limit tracking from response headers — §2.7
- Order book depth for walk-the-book — §2.8
- WebSocket user data stream — separate work item
- Stop, Stop-Limit, Take Profit order types — future execution modes
- cancel_replace_order — deferred until bracket mode
- Logging via structlog — add when Execution Manager integration needs it
- Pagination for large result sets — not needed at testnet scale
